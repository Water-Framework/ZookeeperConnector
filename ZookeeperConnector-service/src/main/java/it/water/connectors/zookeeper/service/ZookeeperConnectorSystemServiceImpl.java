package it.water.connectors.zookeeper.service;

import it.water.connectors.zookeeper.api.ZookeeperConnectorSystemApi;
import it.water.connectors.zookeeper.model.ZKConstants;
import it.water.connectors.zookeeper.model.ZKData;
import it.water.core.api.bundle.ApplicationProperties;
import it.water.core.api.interceptors.OnActivate;
import it.water.core.api.interceptors.OnDeactivate;
import it.water.core.interceptors.annotations.FrameworkComponent;
import it.water.core.service.BaseSystemServiceImpl;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.leader.LeaderLatch;
import org.apache.curator.framework.recipes.leader.LeaderLatchListener;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.data.Stat;

import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;


/**
 * @Generated by Water Generator
 * System Service Api Class for ZookeeperConnector entity.
 */
@FrameworkComponent
public class ZookeeperConnectorSystemServiceImpl extends BaseSystemServiceImpl implements ZookeeperConnectorSystemApi {
    private CuratorFramework client;
    private HashMap<String, LeaderLatch> leaderSelectorsMap;
    private Map<String, InterProcessMutex> interProcessMutex;
    private String nodeId = "";
    private String layer = "";
    private String zkUrl = "localhost:2181";
    private String zookeeperBasePath = ZKConstants.WATER_ZOOKEEPER_DEFAULT_BASE_PATH;
    private Thread registrationThread;

    public ZookeeperConnectorSystemServiceImpl() {
        getLog().debug("Creating service for ZookeeperConnectorSystemApi");
        leaderSelectorsMap = new HashMap<>();
        interProcessMutex = new HashMap<>();
    }

    /**
     * On Activation, zookeeper module loads the configuration, connects to zookeeper and tries to write
     * info about the current container in which it's executed
     */
    @OnActivate
    public void activate(ApplicationProperties applicationProperties) {
        getLog().debug("Activating Zookeeper Connector System API");
        zookeeperBasePath = applicationProperties.getPropertyOrDefault(ZKConstants.WATER_ZOOKEEPER_PATH, ZKConstants.WATER_ZOOKEEPER_DEFAULT_BASE_PATH);
        nodeId = applicationProperties.getPropertyOrDefault(ZKConstants.SERVICE_NODE_ID, "default-node-id");
        layer = applicationProperties.getPropertyOrDefault(ZKConstants.SERVICE_LAYER, "default-layer");
        zkUrl = applicationProperties.getPropertyOrDefault(ZKConstants.ZOOKEEPER_CONNECTION_URL, "localhost:2181");
        createZookeeperConnection();
    }

    @Override
    public String getCurrentNodePath() {
        return zookeeperBasePath + "/" + layer + "/" + nodeId;
    }

    @Override
    public String getCurrentServicePath(String serviceName, String instanceId) {
        return zookeeperBasePath + "/services/" + serviceName + "/" + instanceId;
    }

    private void createZookeeperConnection() {
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);
        getLog().debug("Connecting to zookeeper {}", zkUrl);
        this.registrationThread = new Thread(() -> {
            ZookeeperConnectorSystemServiceImpl.this.client = CuratorFrameworkFactory.newClient(zkUrl, retryPolicy);
            client.start();
            ZookeeperConnectorSystemServiceImpl.this.registerContainerInfo();
        });
        registrationThread.start();
    }

    public void awaitRegistration() throws InterruptedException {
        if (this.registrationThread != null && this.registrationThread.isAlive())
            this.registrationThread.join();
    }

    @OnDeactivate
    public void deactivate() {
        getLog().debug("Disconnecting from Zookeeper....");
        this.client.close();
    }

    /**
     * Writes to zookeeper current container info
     */
    private void registerContainerInfo() {
        try {
            ZKData data = new ZKData();
            String path = this.getCurrentNodePath();
            data.addParam("nodeId", nodeId.getBytes(StandardCharsets.UTF_8));
            data.addParam("layer", layer.getBytes(StandardCharsets.UTF_8));
            if (getLog().isDebugEnabled())
                getLog().debug("Registering Container info on zookeeper with nodeId: {} layer: {} data: \n {}", nodeId, layer, new String(data.getBytes()));
            this.create(CreateMode.EPHEMERAL, path, data.getBytes(), true);
        } catch (Exception e) {
            getLog().error(e.getMessage(), e);
        }
    }

    public void registerLeadershipComponent(String leadershipPath) {
        String zkPath = zookeeperBasePath + leadershipPath;
        try {
            this.startLeaderLatch(zkPath);
        } catch (Exception e) {
            getLog().error(e.getMessage(), e);
        }
    }

    public void unregisterLeadershipComponent(String leadershipPath) {
        String zkPath = zookeeperBasePath + leadershipPath;
        try {
            this.closeLeaderLatch(zkPath);
        } catch (Exception e) {
            getLog().error(e.getMessage(), e);
        }
    }


    /**
     * @param mode
     * @param path
     * @param data
     * @param createParentFolders
     * @throws Exception
     */
    @Override
    public void create(CreateMode mode, String path, byte[] data, boolean createParentFolders) throws Exception {
        if (createParentFolders)
            this.client.create().creatingParentsIfNeeded().withMode(mode).forPath(path, data);
        else
            this.client.create().withMode(mode).forPath(path, data);
    }

    /**
     * @param path
     * @param data
     * @param createParentFolders
     * @throws Exception
     */
    @Override
    public void createEphemeral(String path, byte[] data, boolean createParentFolders) throws Exception {
        CreateMode mode = CreateMode.EPHEMERAL;
        this.create(mode, path, data, createParentFolders);
    }

    /**
     * @param path
     * @param data
     * @param createParentFolders
     * @throws Exception
     */
    @Override
    public void createPersistent(String path, byte[] data, boolean createParentFolders) throws Exception {
        CreateMode mode = CreateMode.PERSISTENT;
        this.create(mode, path, data, createParentFolders);
    }

    /**
     * @param path
     * @param data
     * @param createParentFolders
     * @throws Exception
     */
    @Override
    public void create(String path, byte[] data, boolean createParentFolders) throws Exception {
        if (createParentFolders)
            this.client.create().creatingParentsIfNeeded().forPath(path, data);
        else
            this.client.create().forPath(path);
    }

    /**
     * @param path
     * @throws Exception
     */
    @Override
    public void delete(String path) throws Exception {
        this.client.delete().quietly().deletingChildrenIfNeeded().forPath(path);
    }

    /**
     * @param path
     * @return
     * @throws Exception
     */
    @Override
    public byte[] read(String path) throws Exception {
        return read(path, false);
    }

    @Override
    public byte[] read(String path, boolean lock) throws Exception {
        if (path.endsWith("/") || path.endsWith("\\"))
            path = path.substring(0, path.length() - 1);
        if (lock)
            lock(path);
        byte[] data = this.client.getData().forPath(path);
        if (lock)
            unlock(path);
        return data;
    }

    /**
     * @param path
     * @return
     * @throws Exception
     */
    @Override
    public void update(String path, byte[] data) throws Exception {
        if (path.endsWith("/") || path.endsWith("\\"))
            path = path.substring(0, path.length() - 1);
        lock(path);
        this.client.setData().forPath(path, data);
        unlock(path);
    }

    @Override
    public boolean checkExists(String path) throws Exception {
        Stat stats = this.client.checkExists().forPath(path);
        return stats != null;
    }

    @Override
    public void addListener(LeaderLatchListener listener, String leadershipPath) {
        String zkPath = zookeeperBasePath + leadershipPath;
        getLog().info("Adding listener to LeaderLatch on zkPath {}", zkPath);
        if (leaderSelectorsMap.containsKey(zkPath))
            leaderSelectorsMap.get(zkPath).addListener(listener);
        else
            getLog().warn("Could not add listener: LeaderLatch does not exist on zkPath {}", zkPath);
    }

    /**
     * @param mutexPath zkNode path
     * @return True if a LeaderLatch exists on path and it has leadership, false otherwise
     */
    public boolean isLeader(String mutexPath) {
        String zkPath = zookeeperBasePath + mutexPath;
        if (leaderSelectorsMap.containsKey(zkPath))
            return leaderSelectorsMap.get(zkPath).hasLeadership();
        return false;
    }

    @Override
    public CuratorFramework getZookeeperCuratorClient() {
        return this.client;
    }

    /**
     * @param mutexPath MutexPath
     * @throws Exception Exception
     */
    @SuppressWarnings("java:S112")
    public void closeLeaderLatch(String mutexPath) throws Exception {
        if (leaderSelectorsMap.containsKey(mutexPath)) {
            LeaderLatch ll = leaderSelectorsMap.remove(mutexPath);
            ll.close();
        }
    }

    /**
     * @param mutexPath
     * @throws Exception
     */
    private void startLeaderLatch(String mutexPath) throws Exception {
        LeaderLatch ll = this.getOrCreateLeaderLatch(mutexPath);
        ll.start();
    }

    /**
     * @param mutexPath
     * @return
     */
    private LeaderLatch getOrCreateLeaderLatch(String mutexPath) {
        LeaderLatch ll = null;
        if (!leaderSelectorsMap.containsKey(mutexPath)) {
            ll = new LeaderLatch(this.client, mutexPath, nodeId);
            leaderSelectorsMap.put(mutexPath, ll);
        } else {
            ll = leaderSelectorsMap.get(mutexPath);
        }
        return ll;
    }

    private void lock(String path) throws Exception {
        interProcessMutex.computeIfAbsent(path, key -> new InterProcessMutex(client, path));
        interProcessMutex.get(path).acquire();
    }

    private void unlock(String path) throws Exception {
        interProcessMutex.computeIfAbsent(path, key -> new InterProcessMutex(client, path));
        interProcessMutex.get(path).release();
    }
}