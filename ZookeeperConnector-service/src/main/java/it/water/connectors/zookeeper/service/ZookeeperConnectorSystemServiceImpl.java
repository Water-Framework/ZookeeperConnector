package it.water.connectors.zookeeper.service;

import it.water.connectors.zookeeper.api.ZookeeperClient;
import it.water.connectors.zookeeper.api.ZookeeperConnectorSystemApi;
import it.water.connectors.zookeeper.model.ZKConstants;
import it.water.core.api.bundle.ApplicationProperties;
import it.water.core.api.interceptors.OnActivate;
import it.water.core.api.interceptors.OnDeactivate;
import it.water.core.api.service.cluster.ClusterNodeOptions;
import it.water.core.interceptors.annotations.FrameworkComponent;
import it.water.core.interceptors.annotations.Inject;
import it.water.core.service.BaseSystemServiceImpl;
import lombok.Setter;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.imps.CuratorFrameworkState;
import org.apache.curator.framework.recipes.leader.LeaderLatch;
import org.apache.curator.framework.recipes.leader.LeaderLatchListener;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.data.Stat;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;


/**
 * @Generated by Water Generator
 * System Service Api Class for ZookeeperConnector entity.
 */
@FrameworkComponent
public class ZookeeperConnectorSystemServiceImpl extends BaseSystemServiceImpl implements ZookeeperConnectorSystemApi {
    @Inject
    @Setter
    private ClusterNodeOptions clusterNodeOptions;
    private CuratorFramework client;
    private HashMap<String, LeaderLatch> leaderSelectorsMap;
    private Map<String, InterProcessMutex> interProcessMutex;
    private String zkUrl = "localhost:2181";
    private String zookeeperBasePath = ZKConstants.WATER_ZOOKEEPER_DEFAULT_BASE_PATH;
    private Thread registrationThread;
    private Set<ZookeeperClient> zookeeperClients;

    public ZookeeperConnectorSystemServiceImpl() {
        getLog().debug("Creating service for ZookeeperConnectorSystemApi");
        leaderSelectorsMap = new HashMap<>();
        interProcessMutex = new HashMap<>();
        this.zookeeperClients = new HashSet<>();
    }

    @Override
    public void addZookeeperClient(ZookeeperClient zookeeperClient) {
        this.zookeeperClients.add(zookeeperClient);
        //When adding a client if connection is already open, let's notify it
        notifyConnectionOpened(zookeeperClient);
    }

    @Override
    public void removeZookeeperClient(ZookeeperClient zookeeperClient) {
        this.zookeeperClients.remove(zookeeperClient);
    }

    private void notifyConnectionOpened(ZookeeperClient zookeeperClient) {
        if (this.client != null && client.getState() == CuratorFrameworkState.STARTED) {
            zookeeperClient.onConnectionOpened(this, clusterNodeOptions);
        }
    }

    private void notifyConnectionClosed(ZookeeperClient zookeeperClient) {
        zookeeperClient.onConnectionClosed();
    }

    /**
     * On Activation, zookeeper module loads the configuration, connects to zookeeper and tries to write
     * info about the current container in which it's executed
     */
    @OnActivate
    public void activate(ApplicationProperties applicationProperties) {
        getLog().debug("Activating Zookeeper Connector System API");
        zookeeperBasePath = applicationProperties.getPropertyOrDefault(ZKConstants.WATER_ZOOKEEPER_PATH, ZKConstants.WATER_ZOOKEEPER_DEFAULT_BASE_PATH);
        zkUrl = applicationProperties.getPropertyOrDefault(ZKConstants.ZOOKEEPER_CONNECTION_URL, "localhost:2181");
        createZookeeperConnection();
    }

    @Override
    public String getCurrentNodePath() {
        return getPeerPath(this.clusterNodeOptions.getNodeId());
    }

    @Override
    public String getClusterPath() {
        return zookeeperBasePath + "/" + this.clusterNodeOptions.getLayer();
    }

    @Override
    public String getPeerPath(String nodeId) {
        return getClusterPath() + "/" + nodeId;
    }

    @Override
    public String getCurrentServicePath(String serviceName, String instanceId) {
        return zookeeperBasePath + "/services/" + serviceName + "/" + instanceId;
    }

    private void createZookeeperConnection() {
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 10);
        getLog().debug("Connecting to zookeeper {}", zkUrl);
        this.registrationThread = new Thread(() -> {
            ZookeeperConnectorSystemServiceImpl.this.client = CuratorFrameworkFactory.newClient(zkUrl, retryPolicy);
            client.start();
            ZookeeperConnectorSystemServiceImpl.this.zookeeperClients.forEach(this::notifyConnectionOpened);
        });
        registrationThread.start();
    }

    public synchronized void awaitRegistration() throws InterruptedException {
        if (this.client == null && this.registrationThread != null && this.registrationThread.isAlive()) {
            this.registrationThread.join();
            if(this.registrationThread.isAlive())
                getLog().error("Zookeeper connection attemp still runnning after 30 seconds, please check network or configuration!");
        }
    }

    @OnDeactivate
    public void deactivate() {
        getLog().debug("Disconnecting from Zookeeper....");
        this.client.close();
        ZookeeperConnectorSystemServiceImpl.this.zookeeperClients.forEach(this::notifyConnectionClosed);
    }


    public void registerLeadershipComponent(String leadershipPath) {
        String zkPath = zookeeperBasePath + leadershipPath;
        try {
            this.startLeaderLatch(zkPath);
        } catch (Exception e) {
            getLog().error(e.getMessage(), e);
        }
    }

    public void unregisterLeadershipComponent(String leadershipPath) {
        String zkPath = zookeeperBasePath + leadershipPath;
        try {
            this.closeLeaderLatch(zkPath);
        } catch (Exception e) {
            getLog().error(e.getMessage(), e);
        }
    }

    /**
     * @param mode
     * @param path
     * @param data
     * @param createParentFolders
     * @throws Exception
     */
    @Override
    public void create(CreateMode mode, String path, byte[] data, boolean createParentFolders) throws Exception {
        if (createParentFolders)
            this.client.create().creatingParentsIfNeeded().withMode(mode).forPath(path, data);
        else
            this.client.create().withMode(mode).forPath(path, data);
    }

    /**
     * @param path
     * @param data
     * @param createParentFolders
     * @throws Exception
     */
    @Override
    public void createEphemeral(String path, byte[] data, boolean createParentFolders) throws Exception {
        CreateMode mode = CreateMode.EPHEMERAL;
        this.create(mode, path, data, createParentFolders);
    }

    /**
     * @param path
     * @param data
     * @param createParentFolders
     * @throws Exception
     */
    @Override
    public void createPersistent(String path, byte[] data, boolean createParentFolders) throws Exception {
        CreateMode mode = CreateMode.PERSISTENT;
        this.create(mode, path, data, createParentFolders);
    }

    /**
     * @param path
     * @param data
     * @param createParentFolders
     * @throws Exception
     */
    @Override
    public void create(String path, byte[] data, boolean createParentFolders) throws Exception {
        if (createParentFolders)
            this.client.create().creatingParentsIfNeeded().forPath(path, data);
        else
            this.client.create().forPath(path);
    }

    /**
     * @param path
     * @throws Exception
     */
    @Override
    public void delete(String path) throws Exception {
        this.client.delete().quietly().deletingChildrenIfNeeded().forPath(path);
    }

    /**
     * @param path
     * @return
     * @throws Exception
     */
    @Override
    public byte[] read(String path) throws Exception {
        return read(path, false);
    }

    @Override
    public byte[] read(String path, boolean lock) throws Exception {
        if (path.endsWith("/") || path.endsWith("\\"))
            path = path.substring(0, path.length() - 1);
        if (lock)
            lock(path);
        byte[] data = this.client.getData().forPath(path);
        if (lock)
            unlock(path);
        return data;
    }

    /**
     * @param path
     * @return
     * @throws Exception
     */
    @Override
    public void update(String path, byte[] data) throws Exception {
        if (path.endsWith("/") || path.endsWith("\\"))
            path = path.substring(0, path.length() - 1);
        lock(path);
        this.client.setData().forPath(path, data);
        unlock(path);
    }

    @Override
    public boolean pathExists(String path) {
        try {
            Stat stats = this.client.checkExists().forPath(path);
            return stats != null;
        } catch (Exception e) {
            getLog().error(e.getMessage(), e);
        }
        return false;
    }

    @Override
    public void addListener(LeaderLatchListener listener, String leadershipPath) {
        String zkPath = zookeeperBasePath + leadershipPath;
        getLog().info("Adding listener to LeaderLatch on zkPath {}", zkPath);
        if (leaderSelectorsMap.containsKey(zkPath))
            leaderSelectorsMap.get(zkPath).addListener(listener);
        else
            getLog().warn("Could not add listener: LeaderLatch does not exist on zkPath {}", zkPath);
    }

    /**
     * @param mutexPath zkNode path
     * @return True if a LeaderLatch exists on path and it has leadership, false otherwise
     */
    public boolean isLeader(String mutexPath) {
        String zkPath = zookeeperBasePath + mutexPath;
        if (leaderSelectorsMap.containsKey(zkPath))
            return leaderSelectorsMap.get(zkPath).hasLeadership();
        return false;
    }

    @Override
    public CuratorFramework getZookeeperCuratorClient() {
        return this.client;
    }

    /**
     * @param mutexPath MutexPath
     * @throws Exception Exception
     */
    @SuppressWarnings("java:S112")
    public void closeLeaderLatch(String mutexPath) throws Exception {
        if (leaderSelectorsMap.containsKey(mutexPath)) {
            LeaderLatch ll = leaderSelectorsMap.remove(mutexPath);
            ll.close();
        }
    }

    /**
     * @param mutexPath
     * @throws Exception
     */
    private void startLeaderLatch(String mutexPath) throws Exception {
        LeaderLatch ll = this.getOrCreateLeaderLatch(mutexPath);
        ll.start();
    }

    /**
     * @param mutexPath
     * @return
     */
    private LeaderLatch getOrCreateLeaderLatch(String mutexPath) {
        LeaderLatch ll = null;
        if (!leaderSelectorsMap.containsKey(mutexPath)) {
            ll = new LeaderLatch(this.client, mutexPath, this.clusterNodeOptions.getNodeId());
            leaderSelectorsMap.put(mutexPath, ll);
        } else {
            ll = leaderSelectorsMap.get(mutexPath);
        }
        return ll;
    }

    private void lock(String path) throws Exception {
        interProcessMutex.computeIfAbsent(path, key -> new InterProcessMutex(client, path));
        interProcessMutex.get(path).acquire();
    }

    private void unlock(String path) throws Exception {
        interProcessMutex.computeIfAbsent(path, key -> new InterProcessMutex(client, path));
        interProcessMutex.get(path).release();
    }
}